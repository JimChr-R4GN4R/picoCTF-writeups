# Description:
Why use p and q when I can use more? Connect with <code>nc 2019shell1.picoctf.com 49851</code>.

# Hints:
There's more prime factors than p and q, finding d is going to be different.

# Journey

When I execute the command in terminal, I get this:

###########################################################################################

c: 10700126716619829072748057212031379644817808986162784177172158043260620517065185856420635356633907304635148318815853188110462344063950843152585528823662467837098118179231725941959697329138623200523118493837900598567339160268679336672242136950006904143758178426411145915041024926666404769754489927622855493862441306351807922721387472475638195598
 
 
n: 24938457134014251947760215232231240858089555951274898334541645199426960173289721454316028006118465761239398440209969567610064334798636281965141268459339760693400500925167193360126927502422565650305101641046680875991392193394126604603117480280465414032260934009801025288645550498990823662993806653894032313503725806735887165496773939418890718783
 
 
e: 65537

###########################################################################################

First thought was to find p,q then phi <code>( phi = (p - 1) * ( q - 1 ) )</code> and last d <code>( d = e^(-1) MOD phi )</code>.

So tried to factor n with this great tool --> <code>https://www.alpertron.com.ar/ECM.HTM</code> to find p and q via the factors but it gives this result:

<code>24 938457 134014 251947 760215 232231 240858 089555 951274 898334 541645 199426 960173 289721 454316 028006 118465 761239 398440 209969 567610 064334 798636 281965 141268 459339 760693 400500 925167 193360 126927 502422 565650 305101 641046 680875 991392 193394 126604 603117 480280 465414 032260 934009 801025 288645 550498 990823 662993 806653 894032 313503 725806 735887 165496 773939 418890 718783 (344 digits) = 8865 023599 × 8895 222257 × 8906 680087 × 8942 036561 × 9232 986701 × 9698 406533 × 9845 071829 × 10204 713359 × 10254 526433 × 10677 505151 × 10893 443047 × 11178 642829 × 11618 890061 × 12308 356519 × 12378 849811 × 12418 086097 × 12689 374807 × 12868 219289 × 13594 056127 × 13713 998279 × 13749 759701 × 14214 123367 × 14401 600729 × 14990 258813 × 15075 630931 × 15241 400543 × 15816 772721 × 15928 218569 × 16065 897671 × 16252 022953 × 16289 930567 × 16342 707947 × 17029 421369 × 17109 252703 </code>

The part which we want is this which is after the '='.

<code>8865 023599 × 8895 222257 × 8906 680087 × 8942 036561 × 9232 986701 × 9698 406533 × 9845 071829 × 10204 713359 × 10254 526433 × 10677 505151 × 10893 443047 × 11178 642829 × 11618 890061 × 12308 356519 × 12378 849811 × 12418 086097 × 12689 374807 × 12868 219289 × 13594 056127 × 13713 998279 × 13749 759701 × 14214 123367 × 14401 600729 × 14990 258813 × 15075 630931 × 15241 400543 × 15816 772721 × 15928 218569 × 16065 897671 × 16252 022953 × 16289 930567 × 16342 707947 × 17029 421369 × 17109 252703</code>

The thing is that these are many factors and I did not knew what to do with them....

After few days of trying, I decided to check old RSA writeups.Luckily I found this:
<code>https://github.com/Dvd848/CTFs/blob/master/2018_picoCTF/Super%20Safe%20RSA%203.md</code>

which is realy similar with this one. When read it, I realied that I should multiply all the factors to find phi.
So I made a script which multiply all the factors and put them in phi variable:

<code>
phi = 1
 
phi \*= (factors_list\[l] - 1) # phi = phi * (p - 1)
</code>

and then I find d:

<code>d = inverse(e, phi)</code>

and finaly the plaintext:

<code>print(long_to_bytes(pow(c, d, n)).decode()) # convert from dec to hex and then to ascii</code>

So let's run it!
<code>python3 c-n-e_-phi_-d-_plaintext.py</code>

Flag: picoCTF{too_many_fact0rs_6566973}
